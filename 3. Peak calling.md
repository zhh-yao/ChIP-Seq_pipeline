## Peak calling

Use MACS2 or [MACS3](https://github.com/macs3-project/MACS) to do peak calling. In our calculations, those narrow peaks with a p-value equal to 0.01 were selected.
```shell
macs3 callpeak -t Sample.bam -c Control.bam -f BAMPE -g hs -n Sample --outdir peak_consider_background -method p 0.01 --bdg 2> outputSummary
```
If no background bam file available, peaks can also be called with single input
```shell
macs3 callpeak -t Sample.bam -f BAMPE -g hs -n Sample --outdir peak_without_background -method p 0.01 --bdg 2> outputSummary
```

If you want to do peak calling with `macs3 callpeak` for all the samples automatically, `peak_calling.sh` will work.

### Advanced step-by-step peak calling

In the official website for [MACS3](https://macs3-project.github.io/MACS/index.html), you can also find an advanced step-by-step peak calling tutorial, which can be combined with our case if you want to consider spike-In when doing peak calling

```shell
#!/bin/sh

# determine global parameters
genome_size=2700000000

# we use sample 1 and its control sample 15 as an example
i=1
Sample=Sample_$i
if [ $i -lt 5 ]
then
    j=$(echo $i+14 | bc)
    Control=Sample_$j
else
    j=$(echo $i+10 | bc)
    Control=Sample_$j
fi
echo "Do peak calling for ${Sample} by considering background from ${Control}"
# determine individual parameters 
d=241
ctrl_num_read=12501765
treat_spike_num_read=99
ctrl_spike_num_read=37235

macs3 pileup -f BAMPE -i ${Sample}.sorted.rmDup.rmBL.bam -B --extsize $d -o ${Sample}.pileup.bdg
## build local background track from control
# d background
d2=$(echo $d/2 | bc)
macs3 pileup -f BAMPE -i ${Control}.sorted.rmDup.rmBL.bam -B --extsize $d2 -o ${Control}_d_bg.pileup.bdg
# slocal background
d3=$(echo "scale=4;"$d/1000 | bc)
macs3 pileup -f BAMPE -i ${Control}.sorted.rmDup.rmBL.bam -B --extsize 500 -o ${Control}_1k_bg.pileup.bdg
macs3 bdgopt -i ${Control}_1k_bg.pileup.bdg -m multiply -p $d3 -o ${Control}_1k_bg_norm.bdg
# llocal background
d4=$(echo "scale=4;"$d/10000 | bc)
macs3 pileup -f BAMPE -i ${Control}.sorted.rmDup.rmBL.bam -B --extsize 5000 -o ${Control}_10k_bg.pileup.bdg
macs3 bdgopt -i ${Control}_10k_bg.pileup.bdg -m multiply -p $d4 -o ${Control}_10k_bg_norm.bdg
# Combine and generate the maximum background noise
macs3 bdgcmp -m max -t ${Control}_1k_bg_norm.bdg -c ${Control}_10k_bg_norm.bdg -o ${Control}_1k_10k_bg_norm.bdg
macs3 bdgcmp -m max -t ${Control}_1k_10k_bg_norm.bdg -c ${Control}_d_bg.pileup.bdg -o ${Control}_d_1k_10k_bg_norm.bdg
## scale the ChIP and control to the same sequencing depth
# p=ctrl_num_read*d/genome_size
p=$(echo "scale=8;"$ctrl_num_read\*$d/$genome_size | bc)
macs3 bdgopt -i ${Control}_d_1k_10k_bg_norm.bdg -m max -p $p -o ${Control}_local_bias_raw.bdg
# scaling treat and control based on spike-in
# q=ctrl_spike_num_read/treat_spike_num_read
q=$(echo "scale=8;"$treat_spike_num_read/$ctrl_spike_num_read | bc)
macs3 bdgopt -i ${Control}_local_bias_raw.bdg -m multiply -p $q -o ${Control}_local_lambda.bdg
macs3 bdgopt -i ${Sample}.pileup.bdg -m multiply -p 1 -o ${Sample}_scale.pileup.bdg
## compare ChIP and local lambda to get the scores in qvalue
macs3 bdgcmp -t ${Sample}_scale.pileup.bdg -c ${Control}_local_lambda.bdg -m qpois -o ${Sample}_qvalue.bdg
# or pvalue
macs3 bdgcmp -t ${Sample}_scale.pileup.bdg -c ${Control}_local_lambda.bdg -m ppois -o ${Sample}_pvalue.bdg
# significant peaks with a cutoff c=2, which means the p value should be smaller than 10e-2
macs3 bdgpeakcall -i ${Sample}_pvalue.bdg -c 2 -l $d -o ${Sample}_qval_peaks.bed

```
